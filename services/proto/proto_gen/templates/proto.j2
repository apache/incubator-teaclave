use anyhow;
use teaclave_types;
use teaclave_rpc;
use core::convert::TryFrom;
use teaclave_types::TeaclaveServiceResponseError;
use std::prelude::v1::*;

#[derive(Clone, serde::Serialize, serde::Deserialize, Debug)]
#[serde(tag = "request", rename_all = "snake_case")]
pub enum {{ service.proto_name }}Request {
    {%- for m in service.methods %}
    {{ m.proto_name }}({{ m.input_type }}),
    {%- endfor %}
}

#[derive(Clone, serde::Serialize, serde::Deserialize, Debug)]
#[serde(tag = "response", rename_all = "snake_case")]
pub enum {{ service.proto_name }}Response {
    {%- for m in service.methods %}
    {{ m.proto_name }}({{ m.output_type }}),
    {%- endfor %}
}

pub trait {{ service.proto_name }} {
    {%- for m in service.methods %}
      fn {{ m.name }}(&self, request: teaclave_rpc::Request<crate::{{ proto_impl_mod_name }}::{{ m.input_type }}>) -> teaclave_types::TeaclaveServiceResponseResult<crate::{{ proto_impl_mod_name }}::{{ m.output_type }}>;
    {%- endfor %}

    fn dispatch(&self, request: teaclave_rpc::Request<{{ service.proto_name }}Request>) -> teaclave_types::TeaclaveServiceResponseResult<{{ service.proto_name }}Response> {
         match request.message {
             {%- for m in service.methods %}
             {{ service.proto_name }}Request::{{ m.proto_name }}(r) => {
                 let r = crate::{{ proto_impl_mod_name }}::{{ m.input_type }}::try_from(r)
                     .map_err(|_| TeaclaveServiceResponseError::InternalError("internal".to_string()))?;
                 let r = teaclave_rpc::Request {
                     metadata: request.metadata,
                     message: r,
                 };
                 let response = self.{{ m.name }}(r)?;
                 let response = {{ m.output_type }}::from(response);
                 Ok(response).map({{ service.proto_name }}Response::{{ m.proto_name }})
             },
             {%- endfor %}
         }
    }
}

pub struct {{ service.proto_name }}Client {
    channel: teaclave_rpc::channel::SgxTrustedTlsChannel<{{ service.proto_name }}Request, {{ service.proto_name }}Response>,
    metadata: std::collections::HashMap<std::string::String, std::string::String>,
}

impl {{ service.proto_name }}Client {
    pub fn new(
        channel: teaclave_rpc::channel::SgxTrustedTlsChannel<
            {{ service.proto_name }}Request,
            {{ service.proto_name }}Response
        >
    ) -> anyhow::Result<Self> {
        let metadata = std::collections::HashMap::new();
        Ok(Self { channel, metadata })
    }

    pub fn new_with_metadata(
        channel: teaclave_rpc::channel::SgxTrustedTlsChannel<
            {{ service.proto_name }}Request,
            {{ service.proto_name }}Response
        >,
        metadata: std::collections::HashMap<String, String>,
    ) -> anyhow::Result<Self> {
        Ok(Self { channel, metadata })
    }

    {%- for m in service.methods %}
    pub fn {{ m.name }}<T: Into<{{ m.input_type }}>>(&mut self, request: T) -> teaclave_types::TeaclaveServiceResponseResult<{{ m.output_type }}> {
        let request = {{ service.proto_name }}Request::{{ m.proto_name }}(request.into());
        let request = teaclave_rpc::Request {
            metadata: self.metadata.clone(),
            message: request,
        };

        match self.channel.invoke(request) {
            Ok({{ service.proto_name }}Response::{{ m.proto_name }}(response)) => Ok(response),
            Err(e) => Err(e),
            {%- if service.methods.len() > 1 %}
            _ => Err(TeaclaveServiceResponseError::InternalError("internal".to_string())),
            {%- endif %}
        }
    }
    {%- endfor %}
}
