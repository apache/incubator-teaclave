use anyhow;
use teaclave_rpc;
use core::convert::TryFrom;
use teaclave_types::TeaclaveServiceResponseError;
use std::prelude::v1::*;

type Result<T> = std::result::Result<T, TeaclaveServiceResponseError>;

#[derive(Clone, serde_derive::Serialize, serde_derive::Deserialize, Debug)]
#[serde(tag = "request", rename_all = "snake_case")]
pub enum {{ service.proto_name }}Request {
    {% for m in service.methods %}
    {{ m.proto_name }}({{ m.input_type }}),
    {% endfor %}
}

#[derive(Clone, serde_derive::Serialize, serde_derive::Deserialize, Debug)]
#[serde(tag = "response", rename_all = "snake_case")]
pub enum {{ service.proto_name }}Response {
    {% for m in service.methods %}
    {{ m.proto_name }}({{ m.output_type }}),
    {% endfor %}
}

pub trait {{ service.proto_name }} {
    {% for m in service.methods %}
    fn {{ m.name }}(&self, request: crate::{{ proto_impl_mod_name }}::{{ m.input_type }}) -> Result<crate::{{ proto_impl_mod_name }}::{{ m.output_type }}>;
    {% endfor %}
    fn dispatch(&self, request: {{ service.proto_name }}Request) -> Result<{{ service.proto_name }}Response> {
        match request {
            {% for m in service.methods %}
            {{ service.proto_name }}Request::{{ m.proto_name }}(request) => {
                let request = crate::{{ proto_impl_mod_name }}::{{ m.input_type }}::try_from(request)
                    .map_err(|_| TeaclaveServiceResponseError::InternalError("internal".to_string()))?;
                let response = self.{{ m.name }}(request)?;
                let response = {{ m.output_type }}::from(response);
                Ok(response).map({{ service.proto_name }}Response::{{ m.proto_name }})
            },
            {% endfor %}
        }
    }
}

pub struct {{ service.proto_name }}Client {
    channel: teaclave_rpc::channel::SgxTrustedTlsChannel<{{ service.proto_name }}Request, teaclave_types::TeaclaveServiceResponseResult<{{ service.proto_name }}Response>>,
}

impl {{ service.proto_name }}Client {
    pub fn new(channel: teaclave_rpc::channel::SgxTrustedTlsChannel<{{ service.proto_name }}Request, teaclave_types::TeaclaveServiceResponseResult<{{ service.proto_name }}Response>>) -> anyhow::Result<Self> {
        Ok(Self { channel })
    }

    {% for m in service.methods %}
    pub fn {{ m.name }}(&mut self, request: {{ m.input_type }}) -> teaclave_types::TeaclaveServiceResponseResult<{{ m.output_type }}> {
        let request = {{ service.proto_name }}Request::{{ m.proto_name }}(request);
        let response = match self.channel.invoke(request) {
            Ok(response_result) => {
                response_result
            },
            Err(_) => {
                return Err(TeaclaveServiceResponseError::InternalError("internal".to_string()));
            }
        }?;
        match response {
            {{ service.proto_name }}Response::{{ m.proto_name }}(response) => Ok(response),
            {% if service.methods.len() > 1 -%}
            _ => Err(TeaclaveServiceResponseError::InternalError("internal".to_string())),
            {% endif %}
        }
    }
    {% endfor %}
}